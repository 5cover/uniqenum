import { scopedIdentFn, ident as pureIdent, type IdentFn, identAntecedent, identAntecedentAssert } from './ident.js';
import * as g from './g.js';
import * as fmt from './format.js';
import { type Writer, type Teller } from './writing.js';
import { StableCache } from './StableCache.js';
import type { CodeGenerator, GeneratorConfig } from './types.js';

const iaEnum = identAntecedentAssert('enum');

interface IdentAntecedentPair {
    ident: string;
    i: number | null;
}

const joinMacroName = `_UNIQJ `;
const assertMacroName = `_UNIQA`;

export class C11CodeGenerator implements CodeGenerator {
    constructor(private readonly cfg: GeneratorConfig) {}
    readonly heading = '// Code generated by uniqenum. DO NOT EDIT.\n';
    readonly inits = {
        uniqenum: `#if UNIQENUM_ASSERT==2
#define _UNIQA(N,n,t,...)areuniq##N(__VA_ARGS__)
#elif UNIQENUM_ASSERT==0
#define _UNIQA(N,n,t,...)
#else
#ifdef UNIQENUM_ASSERT_ONCE
#define _UNIQA(N,n,t,...);UNIQENUM_ASSERT_ONCE(areuniq##N(__VA_ARGS__),n,t)
#else
#define _UNIQA(N,n,t,...)_Static_assert(areuniq##N(__VA_ARGS__),"enum has duplicate values: "#n" "#t)
#endif
#endif
`,
        areuniq: `#if UNIQENUM_ASSERT==2
#define _UNIQJ ;
#ifdef UNIQENUM_ASSERT_ALL
#define areuniq2(a,b);UNIQENUM_ASSERT_ALL((a)!=(b),a,b)
#else
#define areuniq2(a,b)_Static_assert((a)!=(b),"duplicate enum values: "#a" and "#b)
#endif
#else 
#define _UNIQJ &&
#define areuniq2(a,b)((a)!=(b))
#endif
`,
    };

    readonly bases = {
        uniqenum: 1,
        areuniq: 2,
    };

    private readonly nameAreuniq = new StableCache<number, { ident: string; i: number | null }>(n => {
        const ident = fmt.format(fmt.string, this.cfg.names.areuniq, { n: n.toString() });
        return {
            ident,
            i: identAntecedent(ident),
        };
    });

    readonly areuniq = (w: Writer, n: number) => {
        // useless under 2. and N=2 is already provided by the header.
        if (n <= 2) return w;
        const k = 3;
        const cliques = this.partitionCliques(n, k);
        const ident = scopedIdentFn(cliques.map(([name]) => name.i).filter(i => i !== null));
        return this.genAreuniq(
            w,
            n,
            w => w.join(joinMacroName, cliques, (w, [name, clique]) => callMacro(w, name.ident, g.map(clique, ident))),
            ident
        );
    };

    private readonly genAreuniq = (w: Writer, n: number, body: Teller, ident = pureIdent) => {
        return defineMacro(w, this.nameAreuniq.get(n).ident, g.seq(n, ident), body);
    };

    readonly uniqenum = (w: Writer, n: number) => {
        if (n < 1) return w;
        const nameUniqenum = fmt.format(fmt.string, this.cfg.names.uniqenum, { n: n.toString() });
        if (n === 1) {
            return this.genUniqenum(w, nameUniqenum, new UniqenumInfo(n, pureIdent));
        }
        const scope = [iaEnum];
        {
            let ia: number | null;
            if (null !== (ia = identAntecedent(nameUniqenum))) scope.push(ia);
            if (null !== (ia = identAntecedent(this.nameAreuniq.get(n).ident))) scope.push(ia);
        }
        const info = new UniqenumInfo(n, scopedIdentFn(scope));
        return this.genUniqenum(w, nameUniqenum, info, w =>
            w
                .str(' _UNIQA(')
                .int(n)
                .str(',')
                .str(info.name)
                .str(',')
                .str(info.type)
                .str(',')
                .join(',', info.keys())
                .str(')')
        );
    };

    private readonly genUniqenum = (w: Writer, name: string, info: UniqenumInfo, rest?: Teller) => {
        return defineMacro(w, name, info.params(), w => {
            w.str('enum ')
                .str(info.name)
                .str('{')
                .join(',', g.unzip([info.keys(), info.values()]), (w, x) => w.join(' ', x))
                .str('}')
                .str(info.type);
            rest?.(w);
        });
    };

    /**
     * split graph in k parts of size (node count) n / K + +(i < n % k), i being the subgraph number (the +() parrt allows to account for when n % k != 0)
     */
    private readonly partitionCliques = (n: number, k: number) => {
        if (n < k) {
            throw new Error('n must be greater than K. use a base case.');
        }
        const basesize = Math.trunc(n / k);

        const cliques: [name: IdentAntecedentPair, items: Generator<number>][] = [];
        for (const [iStart, iEnd] of g.combinations(k)) {
            // iStart and iEnd are graph part numbers
            // compute the subcliques as an union of two subgraphs

            // amount of nodes before iStart
            const iStartOffset = iStart * basesize + Math.min(iStart, n % k);
            const iEndOffset = iEnd * basesize + Math.min(iEnd, n % k);
            const size1 = basesize + +(iStart < n % k);
            const size2 = basesize + +(iEnd < n % k);
            cliques.push([
                this.nameAreuniq.get(size1 + size2),
                g.cat(
                    g.seq(size1, i => iStartOffset + i),
                    g.seq(size2, i => iEndOffset + i)
                ),
            ]);
        }
        return cliques;
    };
}

function defineMacro(w: Writer, name: string, params: Iterable<string>, body: Teller) {
    callMacro(w.str('#define '), name, params);
    body(w);
    return w.str('\n');
}

function callMacro(w: Writer, name: string, args: Iterable<string>) {
    return w
        .str(name)
        .str('(')
        .join(',', args, (w, x) => w.str(x))
        .str(')');
}

class UniqenumInfo {
    constructor(
        readonly n: number,
        private readonly ident: IdentFn
    ) {}

    get name() {
        return this.ident(this.n);
    }

    get type() {
        return this.ident(this.n + 1);
    }

    values() {
        return g.seq(this.n, i => this.ident(this.n + 2 + i));
    }

    keys() {
        return g.seq(this.n, this.ident);
    }

    *params() {
        yield this.name;
        /**
         * 0 -> 0
         * 1 -> n+2
         * 2 -> 1
         * 3 -> n+3
         * 4 -> 2
         * 5 -> n+4
         * 6 -> 3
         * 7 -> n+5
         * ...
         */
        for (const p of g.seq(2 * this.n, i => this.ident((i >> 1) + (i % 2) * (this.n + 2)))) {
            yield p;
        }
        yield this.type;
    }
}
