import { scopedIdentFn, ident as pureIdent, type IdentFn, identAntecedent, identAntecedentAssert } from './ident.js';
import * as g from './g.js';
import * as fmt from './format.js';
import { type Writer, type Teller } from './writing.js';
import { StableCache } from './StableCache.js';
import type { AreuniqMetrics, AreuniqMetricsRecorder, CodeGenerator, GeneratorConfig } from './types.js';

const iaEnum = identAntecedentAssert('enum');

interface IdentAntecedentPair {
    ident: string;
    i: number | null;
}

const joinMacroNameSp = `_UNIQJ `;
const assertMacroName = `_UNIQA`;

export class CCodeGenerator implements CodeGenerator {
    constructor(private readonly cfg: GeneratorConfig) {
        this.metricsRecorder = cfg.metricsRecorder;
    }
    readonly heading = '// Code generated by uniqenum. DO NOT EDIT.\n';
    readonly inits = {
        uniqenum: `#if UNIQENUM_ASSERT==2
#define ${assertMacroName}(N,n,t,...)areuniq##N(__VA_ARGS__)
#elif UNIQENUM_ASSERT==0
#define ${assertMacroName}(N,n,t,...)
#else
#ifdef UNIQENUM_ASSERT_ONCE
#define ${assertMacroName}(N,n,t,...);UNIQENUM_ASSERT_ONCE(areuniq##N(__VA_ARGS__),n,t)
#else
#define ${assertMacroName}(N,n,t,...)_Static_assert(areuniq##N(__VA_ARGS__),"enum has duplicate values: "#n" "#t)
#endif
#endif
`,
        areuniq: `#if UNIQENUM_ASSERT==2
#define ${joinMacroNameSp};
#ifdef UNIQENUM_ASSERT_ALL
#define areuniq2(a,b);UNIQENUM_ASSERT_ALL((a)!=(b),a,b)
#else
#define areuniq2(a,b)_Static_assert((a)!=(b),"duplicate enum values: "#a" and "#b)
#endif
#else 
#define ${joinMacroNameSp}&&
#define areuniq2(a,b)((a)!=(b))
#endif
`,
    };

    readonly bases = {
        uniqenum: 1,
        areuniq: 2,
    };

    private readonly nameAreuniq = new StableCache<number, { ident: string; i: number | null }>(n => {
        const ident = fmt.format(fmt.string, this.cfg.names.areuniq, { n: n.toString() });
        return {
            ident,
            i: identAntecedent(ident),
        };
    });
    private readonly metricsRecorder?: AreuniqMetricsRecorder;
    private readonly areuniqMetrics = new Map<number, AreuniqMetrics>();

    readonly areuniq = (w: Writer, n: number) => {
        this.computeAreuniqMetrics(n);
        // useless under 2. and N=2 is already provided by the header.
        if (n <= 2) return w;
        const k = 3;
        const cliques = this.partitionCliques(n, k);
        const ident = scopedIdentFn(cliques.map(([name]) => name.i).filter(i => i !== null));
        return this.genAreuniq(
            w,
            n,
            w => w.join(joinMacroNameSp, cliques, (w, [name, clique]) => callMacro(w, name.ident, g.map(clique, ident))),
            ident
        );
    };

    private readonly genAreuniq = (w: Writer, n: number, body: Teller, ident = pureIdent) => {
        return defineMacro(w, this.nameAreuniq.get(n).ident, g.seq(n, ident), body);
    };

    readonly uniqenum = (w: Writer, n: number) => {
        if (n < 1) return w;
        const nameUniqenum = fmt.format(fmt.string, this.cfg.names.uniqenum, { n: n.toString() });
        if (n === 1) {
            return this.genUniqenum(w, nameUniqenum, new UniqenumInfo(n, pureIdent));
        }
        const scope = [iaEnum];
        {
            let ia: number | null;
            if (null !== (ia = identAntecedent(nameUniqenum))) scope.push(ia);
            if (null !== (ia = identAntecedent(this.nameAreuniq.get(n).ident))) scope.push(ia);
        }
        const info = new UniqenumInfo(n, scopedIdentFn(scope));
        return this.genUniqenum(w, nameUniqenum, info, w =>
            w
                .str(' ')
                .str(assertMacroName)
                .str('(')
                .int(n)
                .str(',')
                .str(info.name)
                .str(',')
                .str(info.type)
                .str(',')
                .join(',', info.keys())
                .str(')')
        );
    };

    private readonly genUniqenum = (w: Writer, name: string, info: UniqenumInfo, rest?: Teller) => {
        return defineMacro(w, name, info.params(), w => {
            w.str('enum ')
                .str(info.name)
                .str('{')
                .join(',', g.unzip([info.keys(), info.values()]), (w, x) => w.join(' ', x))
                .str('}')
                .str(info.type);
            rest?.(w);
        });
    };

    /**
     * split graph in k parts of size (node count) n / K + +(i < n % k), i being the subgraph number (the +() parrt allows to account for when n % k != 0)
     */
    private readonly partitionCliques = (n: number, k: number) => {
        if (n < k) {
            throw new Error('n must be greater than K. use a base case.');
        }
        const basesize = Math.trunc(n / k);

        const cliques: [name: IdentAntecedentPair & { n: number }, items: Generator<number>][] = [];
        for (const [iStart, iEnd] of g.combinations(k)) {
            // iStart and iEnd are graph part numbers
            // compute the subcliques as an union of two subgraphs

            // amount of nodes before iStart
            const iStartOffset = iStart * basesize + Math.min(iStart, n % k);
            const iEndOffset = iEnd * basesize + Math.min(iEnd, n % k);
            const size1 = basesize + +(iStart < n % k);
            const size2 = basesize + +(iEnd < n % k);
            const combinedSize = size1 + size2;
            cliques.push([
                { ...this.nameAreuniq.get(combinedSize), n: combinedSize },
                g.cat(
                    g.seq(size1, i => iStartOffset + i),
                    g.seq(size2, i => iEndOffset + i)
                ),
            ]);
        }
        return cliques;
    };

    getAreuniqMetrics(n: number): AreuniqMetrics {
        return this.computeAreuniqMetrics(n);
    }

    private computeAreuniqMetrics(n: number): AreuniqMetrics {
        const cached = this.areuniqMetrics.get(n);
        if (cached) return cached;
        if (n < 2) {
            const metrics = { n, depth: 0, comparisons: 0 };
            this.recordAreuniqMetrics(metrics);
            return metrics;
        }
        if (n === 2) {
            const metrics = { n, depth: 1, comparisons: 1 };
            this.recordAreuniqMetrics(metrics);
            return metrics;
        }
        const cliques = this.partitionCliques(n, 3);
        let maxDepth = 0;
        let comparisons = 0;
        for (const [name] of cliques) {
            const child = this.computeAreuniqMetrics(name.n);
            comparisons += child.comparisons;
            if (child.depth > maxDepth) maxDepth = child.depth;
        }
        const metrics = { n, depth: maxDepth + 1, comparisons };
        this.recordAreuniqMetrics(metrics);
        return metrics;
    }

    private recordAreuniqMetrics(metrics: AreuniqMetrics) {
        this.areuniqMetrics.set(metrics.n, metrics);
        this.metricsRecorder?.record(metrics);
    }
}

function defineMacro(w: Writer, name: string, params: Iterable<string>, body: Teller) {
    callMacro(w.str('#define '), name, params);
    body(w);
    return w.str('\n');
}

function callMacro(w: Writer, name: string, args: Iterable<string>) {
    return w
        .str(name)
        .str('(')
        .join(',', args, (w, x) => w.str(x))
        .str(')');
}

class UniqenumInfo {
    constructor(
        readonly n: number,
        private readonly ident: IdentFn
    ) {}

    get name() {
        return this.ident(this.n);
    }

    get type() {
        return this.ident(this.n + 1);
    }

    values() {
        return g.seq(this.n, i => this.ident(this.n + 2 + i));
    }

    keys() {
        return g.seq(this.n, this.ident);
    }

    *params() {
        yield this.name;
        /**
         * 0 -> 0
         * 1 -> n+2
         * 2 -> 1
         * 3 -> n+3
         * 4 -> 2
         * 5 -> n+4
         * 6 -> 3
         * 7 -> n+5
         * ...
         */
        for (const p of g.seq(2 * this.n, i => this.ident((i >> 1) + (i % 2) * (this.n + 2)))) {
            yield p;
        }
        yield this.type;
    }
}
